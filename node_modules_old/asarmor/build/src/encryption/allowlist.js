"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.allowUnencrypted = void 0;
/* eslint-disable no-plusplus */
/* eslint-disable func-names */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/ban-ts-comment */
const path_1 = __importDefault(require("path"));
const module_1 = __importDefault(require("module"));
// @ts-ignore
const originalResolveLookupPaths = module_1.default._resolveLookupPaths;
/**
 * Hooks into `Module._resolveLookupPaths` so it can resolve unencrypted source files.
 * @example
 * allowUnencrypted(['node_modules']); // This will allow resolution of unencrypted code from `node_modules.asar`.
 */
function allowUnencrypted(allowedPaths) {
    function override2args(request, parent) {
        // @ts-ignore
        const result = originalResolveLookupPaths.call(this, request, parent);
        if (!result)
            return result;
        for (let i = 0; i < result.length; i++) {
            if (allowedPaths.includes(path_1.default.basename(result[i]))) {
                result.splice(i + 1, 0, `${result[i]}.asar`);
                i++;
            }
        }
        return result;
    }
    function override3args(request, parent, newReturn) {
        const result = originalResolveLookupPaths.call(
        // @ts-ignore
        this, request, parent, newReturn);
        const paths = newReturn ? result : result[1];
        for (let i = 0; i < paths.length; i++) {
            if (allowedPaths.includes(path_1.default.basename(paths[i]))) {
                paths.splice(i + 1, 0, `${paths[i]}.asar`);
                i++;
            }
        }
        return result;
    }
    // @ts-ignore
    module_1.default._resolveLookupPaths =
        originalResolveLookupPaths.length === 2 ? override2args : override3args;
}
exports.allowUnencrypted = allowUnencrypted;
