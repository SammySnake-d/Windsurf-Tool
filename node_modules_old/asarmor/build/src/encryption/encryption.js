"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encrypt = void 0;
const crypto_1 = __importDefault(require("crypto"));
const path_1 = require("path");
const asar_1 = require("@electron/asar");
const helpers_1 = require("./helpers");
const promises_1 = require("fs/promises");
const fs_extra_1 = require("fs-extra");
/**
 * Encrypts and packages all files into an asar archive.
 */
async function encrypt({ src, dst }) {
    const keyFile = (0, path_1.join)(__dirname, 'key.txt');
    if (!(await (0, fs_extra_1.pathExists)(keyFile))) {
        throw new Error(`Key file '${keyFile}' not found.`);
    }
    const key = Buffer.from((0, helpers_1.fromHex)(await (0, promises_1.readFile)(keyFile)));
    const extractedPath = `${src}.extracted`;
    (0, asar_1.extractAll)(src, extractedPath);
    await (0, asar_1.createPackageWithOptions)(extractedPath, dst, {
        unpack: '*.node', // C++ modules should not be packed
        transform(filename) {
            if ((0, path_1.extname)(filename) == '.js') {
                // generate random 16-byte initialization vector (IV)
                const iv = crypto_1.default.randomBytes(16);
                // whether we have already prefixed the first chunk of content with the IV
                let hasPrefix = false;
                const cipher = crypto_1.default.createCipheriv('aes-256-cbc', key, iv);
                cipher.setAutoPadding(true);
                cipher.setEncoding('base64');
                // monkey patch push method to put the IV in front of the encrypted data
                const _p = cipher.push;
                cipher.push = function (chunk, enc) {
                    if (!hasPrefix && chunk != null) {
                        hasPrefix = true;
                        return _p.call(this, Buffer.concat([iv, chunk]), enc);
                    }
                    else {
                        return _p.call(this, chunk, enc);
                    }
                };
                return cipher;
            }
        },
    });
    await (0, fs_extra_1.remove)(extractedPath);
}
exports.encrypt = encrypt;
