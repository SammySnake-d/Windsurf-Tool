"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeKeySync = exports.writeKey = exports.generateRandomKey = exports.fromHex = exports.toHex = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const fs_1 = __importDefault(require("fs"));
const crypto_1 = __importDefault(require("crypto"));
/**
 * Convert an encryption key to a comma separeted hex string.
 * @param key encryption key in plaintext
 */
function toHex(key) {
    const hex = Array.prototype.map
        .call(Buffer.from(key), (v) => '0x' + ('0' + v.toString(16)).slice(-2))
        .toString();
    return Buffer.from(hex);
}
exports.toHex = toHex;
/**
 * Convert a comma separated hex string to a plaintext encryption key.
 * @param key comma separated hex string
 */
function fromHex(key) {
    return Buffer.from(key
        .toString()
        .trim()
        .split(',')
        .map((v) => Number(v.trim())));
}
exports.fromHex = fromHex;
function generateRandomKey() {
    return crypto_1.default.randomBytes(32);
}
exports.generateRandomKey = generateRandomKey;
async function writeKey(key, filePath) {
    await promises_1.default.writeFile(filePath, toHex(key));
    return Buffer.from(key);
}
exports.writeKey = writeKey;
function writeKeySync(key, filePath) {
    fs_1.default.writeFileSync(filePath, toHex(key));
    return Buffer.from(key);
}
exports.writeKeySync = writeKeySync;
